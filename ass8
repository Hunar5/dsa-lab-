#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* left;
    Node* right;
    Node(int val) : data(val), left(NULL), right(NULL) {}
};

Node* insert(Node* root, int val) {
    if(!root) return new Node(val);
    if(val < root->data) root->left = insert(root->left,val);
    else if(val > root->data) root->right = insert(root->right,val);
    return root;
}

Node* search(Node* root,int key) {
    if(!root || root->data==key) return root;
    if(key < root->data) return search(root->left,key);
    return search(root->right,key);
}

Node* findMin(Node* root) {
    while(root && root->left) root=root->left;
    return root;
}
Node* findMax(Node* root) {
    while(root && root->right) root=root->right;
    return root;
}

void preorder(Node* root) {
    if(!root) return;
    cout<<root->data<<" ";
    preorder(root->left);
    preorder(root->right);
}
void inorder(Node* root) {
    if(!root) return;
    inorder(root->left);
    cout<<root->data<<" ";
    inorder(root->right);
}
void postorder(Node* root) {
    if(!root) return;
    postorder(root->left);
    postorder(root->right);
    cout<<root->data<<" ";
}

Node* deleteNode(Node* root,int key) {
    if(!root) return root;
    if(key<root->data) root->left=deleteNode(root->left,key);
    else if(key>root->data) root->right=deleteNode(root->right,key);
    else {
        if(!root->left) { Node* temp=root->right; delete root; return temp; }
        else if(!root->right) { Node* temp=root->left; delete root; return temp; }
        Node* temp=findMin(root->right);
        root->data=temp->data;
        root->right=deleteNode(root->right,temp->data);
    }
    return root;
}

int maxDepth(Node* root) {
    if(!root) return 0;
    int l=maxDepth(root->left);
    int r=maxDepth(root->right);
    return (l>r?l:r)+1;
}
int minDepth(Node* root) {
    if(!root) return 0;
    if(!root->left) return 1+minDepth(root->right);
    if(!root->right) return 1+minDepth(root->left);
    int l=minDepth(root->left);
    int r=minDepth(root->right);
    return (l<r?l:r)+1;
}

bool isBSTUtil(Node* root,int minVal,int maxVal) {
    if(!root) return true;
    if(root->data<=minVal || root->data>=maxVal) return false;
    return isBSTUtil(root->left,minVal,root->data) && isBSTUtil(root->right,root->data,maxVal);
}
bool isBST(Node* root) {
    return isBSTUtil(root,-1000000,1000000);
}

void heapify(int arr[], int n, int i) {
    int largest=i;
    int l=2*i+1, r=2*i+2;
    if(l<n && arr[l]>arr[largest]) largest=l;
    if(r<n && arr[r]>arr[largest]) largest=r;
    if(largest!=i) {
        swap(arr[i],arr[largest]);
        heapify(arr,n,largest);
    }
}
void heapSort(int arr[], int n) {
    for(int i=n/2-1;i>=0;i--) heapify(arr,n,i);
    for(int i=n-1;i>0;i--) {
        swap(arr[0],arr[i]);
        heapify(arr,i,0);
    }
}

class PriorityQueue {
    int heap[100];
    int size;
public:
    PriorityQueue() { size=0; }
    void push(int x) {
        heap[size]=x; int i=size; size++;
        while(i>0 && heap[(i-1)/2]<heap[i]) {
            swap(heap[i],heap[(i-1)/2]);
            i=(i-1)/2;
        }
    }
    void pop() {
        if(size==0) return;
        heap[0]=heap[size-1]; size--;
        heapify(heap,size,0);
    }
    int top() { return size==0?-1:heap[0]; }
    bool empty() { return size==0; }
};

int main() {
    Node* root=NULL;
    PriorityQueue pq;
    int choice,val,key;
    do {
        cout<<"\n--- Lab 8 Menu ---\n";
        cout<<"1. Insert BST\n2. Delete BST Node\n3. Preorder\n4. Inorder\n5. Postorder\n";
        cout<<"6. Search\n7. Min Element\n8. Max Element\n9. Max Depth\n10. Min Depth\n";
        cout<<"11. Check if BST\n12. Heap Sort\n13. PQ Push\n14. PQ Pop\n15. PQ Top\n0. Exit\n";
        cout<<"Enter choice: "; cin>>choice;

        switch(choice) {
            case 1: cout<<"Enter value: "; cin>>val; root=insert(root,val); break;
            case 2: cout<<"Enter key: "; cin>>key; root=deleteNode(root,key); break;
            case 3: preorder(root); cout<<endl; break;
            case 4: inorder(root); cout<<endl; break;
            case 5: postorder(root); cout<<endl; break;
            case 6: cout<<"Enter key: "; cin>>key; cout<<(search(root,key)?"Found\n":"Not Found\n"); break;
            case 7: cout<<"Min: "<<(findMin(root)?findMin(root)->data:-1)<<endl; break;
            case 8: cout<<"Max: "<<(findMax(root)?findMax(root)->data:-1)<<endl; break;
            case 9: cout<<"Max Depth: "<<maxDepth(root)<<endl; break;
            case 10: cout<<"Min Depth: "<<minDepth(root)<<endl; break;
            case 11: cout<<(isBST(root)?"Valid BST\n":"Not BST\n"); break;
            case 12: {int n; cout<<"Enter size: "; cin>>n; int arr[100]; for(int i=0;i<n;i++) cin>>arr[i]; heapSort(arr,n); for(int i=0;i<n;i++) cout<<arr[i]<<" "; cout<<endl;} break;
            case 13: cout<<"Enter value: "; cin>>val; pq.push(val); break;
            case 14: pq.pop(); break;
            case 15: cout<<"Top: "<<pq.top()<<endl; break;
        }
    } while(choice!=0);
    return 0;
}
